# seel/ezkl_attestor.py

import logging
import os
import json

try:
    import ezkl
    # A simple check, might need refinement based on ezkl API usage
    if ezkl.__version__:
        EZKL_INSTALLED = True
    else:
        EZKL_INSTALLED = False
except ImportError:
    EZKL_INSTALLED = False

# Potentially other imports needed later for ONNX handling, etc.

logger = logging.getLogger(__name__)

# Define expected ezkl artifact filenames (adjust as needed)
EZKL_PROOF_FILENAME = "ezkl_proof.pf"
EZKL_SETTINGS_FILENAME = "settings.json" # Default ezkl name
EZKL_VK_FILENAME = "vk.key"          # Default ezkl name
EZKL_COMPILED_MODEL = "model.compiled" # Default ezkl name
EZKL_PK_FILENAME = "pk.key"          # Proving key (generated during prove usually)

class EzklError(Exception):
    """Custom exception for ezkl related errors."""
    pass

def generate_ezkl_attestation(
    onnx_model_path: str,
    input_data_path: str, # ezkl often needs input data to shape the circuit
    output_dir: str # Directory to store intermediate/output files (BUNDLE dir)
) -> dict:
    """
    Generates ezkl settings, compiles circuit, generates VK, gets SRS.
    Does NOT yet generate the actual proof.

    Args:
        onnx_model_path: Path to the exported ONNX model file.
        input_data_path: Path to a file containing sample input data (e.g., JSON)
                         required by ezkl for setup/gen-witness.
        output_dir: Path to the bundle directory where artifacts will be stored.

    Returns:
        A dictionary containing attestation results:
        {
            "type": "ezkl",
            "model_onnx_path": str | None, # Relative path in bundle (will be added by bundler)
            "compiled_model_path": str | None, # Relative path in bundle
            "settings_path": str | None,   # Relative path in bundle
            "vk_path": str | None,         # Relative path in bundle
            "error": str | None            # Error message if generation failed
        }
        Returns None values on failure.
    """
    if not EZKL_INSTALLED:
        logger.error("ezkl Python library not found.")
        raise EzklError("ezkl library not installed")

    logger.info(f"Starting ezkl MVP setup for model: {onnx_model_path}")

    # Define paths for artifacts within the target bundle directory
    settings_path = os.path.join(output_dir, EZKL_SETTINGS_FILENAME)
    vk_path = os.path.join(output_dir, EZKL_VK_FILENAME)
    compiled_model_path = os.path.join(output_dir, EZKL_COMPILED_MODEL)
    # pk_path = os.path.join(output_dir, EZKL_PK_FILENAME) # PK generated by prove

    result = {
        "type": "ezkl",
        "model_onnx_path": None, # This will be set by the bundler when copying the ONNX file
        "compiled_model_path": None,
        "settings_path": None,
        "vk_path": None,
        "error": None
    }

    try:
        # --- ezkl Workflow Steps (MVP Setup) ---
        
        # 1. Generate Settings File
        logger.info(f"Generating ezkl settings file at: {settings_path}")
        # Uses polynomial commitment scheme (PCS) KZG by default
        res = ezkl.gen_settings(
            model=onnx_model_path,
            output=settings_path,
            # input_visibility="private", # Removed
            # output_visibility="public",# Removed
            # param_visibility="fixed",  # Removed
            # Specify scale, logrows etc. or let ezkl determine defaults
        )
        # Check return code if necessary (ezkl functions often return result codes)
        # if res is False or res != 0: # Adjust based on ezkl API specifics
        #    raise EzklError(f"ezkl.gen_settings call failed.")
        logger.info("ezkl settings generated.")

        # 2. Compile Circuit (and generate VK)
        logger.info(f"Compiling ezkl circuit for: {onnx_model_path}")
        ezkl.compile_circuit(
            model=onnx_model_path,
            compiled_circuit=compiled_model_path,
            settings_path=settings_path
            # This implicitly generates the vk at vk_path derived from compiled_circuit path
        )
        # Check if VK was created where expected
        if not os.path.exists(vk_path):
             # vk_path might be generated based on compiled_circuit path differently?
             # Let's assume compile_circuit places it based on the compiled name for now.
             logger.warning(f"Verification key not found at expected path: {vk_path} after compile. Checking near compiled model.")
             # Attempt to find VK if name matches default relative to compiled model path
             potential_vk_path = compiled_model_path.replace(EZKL_COMPILED_MODEL, EZKL_VK_FILENAME)
             if os.path.exists(potential_vk_path):
                  logger.info(f"Found VK at {potential_vk_path}. Adjusting path.")
                  vk_path = potential_vk_path # Adjust if found elsewhere
             else:
                  raise FileNotFoundError(f"Verification key {EZKL_VK_FILENAME} not generated by compile_circuit at expected location.")
        
        logger.info(f"ezkl circuit compiled and VK generated at: {vk_path}")

        # 3. Get SRS (Structured Reference String)
        logger.info("Downloading/Verifying ezkl SRS...")
        # This ensures the parameters for KZG are available locally
        # Does not typically produce a file directly in the bundle
        srs_path = ezkl.get_srs(settings_path=settings_path)
        if not srs_path or not os.path.exists(srs_path):
             raise RuntimeError(f"Failed to get or verify SRS file. Path: {srs_path}")
        logger.info(f"ezkl SRS available at: {srs_path}")

        # --- Setup successful, proof generation pending --- 
        result["compiled_model_path"] = EZKL_COMPILED_MODEL # Relative path in bundle
        result["settings_path"] = EZKL_SETTINGS_FILENAME # Relative path in bundle
        result["vk_path"] = os.path.basename(vk_path) # Use basename in case path adjusted
        logger.info("ezkl MVP setup (settings, compile, vk, srs) completed successfully.")

        # --- Still need to implement gen_witness and prove ---
        logger.warning("Actual ezkl proof generation (gen_witness, prove) is not yet implemented.")
        raise NotImplementedError("ezkl witness and proof generation logic is pending.")

    except NotImplementedError as e:
         result["error"] = "ezkl proof generation not implemented."
         logger.error(result["error"])
    except FileNotFoundError as e:
        error_msg = f"File not found during ezkl setup: {e}"
        result["error"] = error_msg
        logger.error(error_msg, exc_info=True)
    except Exception as e:
        error_msg = f"ezkl setup failed: {e}"
        result["error"] = error_msg
        logger.error(error_msg, exc_info=True)

    return result


def verify_ezkl_attestation(
    proof_path: str,
    settings_path: str,
    vk_path: str
) -> bool:
    """
    Verifies an ezkl proof using the settings and verification key.

    Args:
        proof_path: Path to the ezkl proof file (.pf).
        settings_path: Path to the ezkl settings file (.json).
        vk_path: Path to the ezkl verification key file (.key).

    Returns:
        True if verification is successful, False otherwise.
    """
    if not EZKL_INSTALLED:
        logger.error("Cannot verify ezkl attestation: ezkl library not found.")
        return False

    logger.info(f"Verifying ezkl proof: {proof_path}")
    try:
        # --- TODO: Implement Actual ezkl Verification ---
        # ezkl.verify(proof_path, settings_path, vk_path)
        # logger.info("ezkl verification successful.")
        # return True

        # --- Placeholder ---
        logger.warning("ezkl verification is not yet implemented.")
        raise NotImplementedError("ezkl proof verification logic is pending.")

    except NotImplementedError as e:
        logger.error("ezkl verification not implemented.")
        return False
    except Exception as e:
        logger.error(f"ezkl verification failed: {e}", exc_info=True)
        return False

# Example Usage Block (Optional - for direct testing)
if __name__ == "__main__":
    logging.basicConfig(level=logging.INFO)
    logger.info("Testing ezkl attestor module (placeholders)...")

    # Create dummy files/dirs for testing placeholders
    os.makedirs("temp_ezkl_test", exist_ok=True)
    with open("temp_ezkl_test/dummy_model.onnx", "w") as f: f.write("")
    with open("temp_ezkl_test/dummy_input.json", "w") as f: json.dump({"input_data": [[0.0]]}, f)

    try:
        attestation_result = generate_ezkl_attestation(
            onnx_model_path="temp_ezkl_test/dummy_model.onnx",
            input_data_path="temp_ezkl_test/dummy_input.json",
            output_dir="temp_ezkl_test"
        )
        print(f"Attestation Generation Result: {attestation_result}")
    except EzklError as e:
        print(f"Attestation Generation Failed as expected (Library check): {e}")
    except NotImplementedError as e:
        print(f"Attestation Generation Failed as expected (Not implemented): {e}")


    # Dummy verification paths (won't work until generation is implemented)
    try:
        is_valid = verify_ezkl_attestation(
            proof_path="temp_ezkl_test/ezkl_proof.pf",
            settings_path="temp_ezkl_test/ezkl_settings.json",
            vk_path="temp_ezkl_test/ezkl_vk.key"
        )
        print(f"Verification Result: {is_valid}")
    except NotImplementedError as e:
         print(f"Verification Failed as expected (Not implemented): {e}")


    # Clean up dummy files
    import shutil
    # Temporarily disable cleanup for inspection if needed
    # shutil.rmtree("temp_ezkl_test") 
    print("Test complete. Dummy files left in temp_ezkl_test/") 